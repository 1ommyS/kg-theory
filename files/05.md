
## 5. Аффинные преобразования. Структура матрицы преобразования однородных координат для физического трехмерного пространства.

### 5.1. Понятие аффинных преобразований

**Аффинные преобразования** — это класс геометрических преобразований, включающих линейные преобразования (например, поворот, масштабирование, отражение) и параллельные переносы. В отличие от изометрий, аффинные преобразования могут изменять длины и углы объектов.

### 5.2. Основные типы аффинных преобразований

1. **Перенос (Translation)**:
    - Сдвиг объекта в пространстве без изменения его ориентации или размера.
    - **Матрица преобразования**:
      \[
      T = \begin{bmatrix}
      1 & 0 & 0 & t_x \\
      0 & 1 & 0 & t_y \\
      0 & 0 & 1 & t_z \\
      0 & 0 & 0 & 1
      \end{bmatrix}
      \]

2. **Масштабирование (Scaling)**:
    - Изменение размера объекта по осям.
    - **Матрица преобразования**:
      \[
      S = \begin{bmatrix}
      s_x & 0 & 0 & 0 \\
      0 & s_y & 0 & 0 \\
      0 & 0 & s_z & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}
      \]

3. **Поворот (Rotation)**:
    - Вращение объекта вокруг одной из осей.
    - **Матрицы преобразования**:
        - Вращение вокруг оси X на угол θ:
          \[
          R_x(\theta) = \begin{bmatrix}
          1 & 0 & 0 & 0 \\
          0 & \cos\theta & -\sin\theta & 0 \\
          0 & \sin\theta & \cos\theta & 0 \\
          0 & 0 & 0 & 1
          \end{bmatrix}
          \]
        - Вращение вокруг оси Y на угол θ:
          \[
          R_y(\theta) = \begin{bmatrix}
          \cos\theta & 0 & \sin\theta & 0 \\
          0 & 1 & 0 & 0 \\
          -\sin\theta & 0 & \cos\theta & 0 \\
          0 & 0 & 0 & 1
          \end{bmatrix}
          \]
        - Вращение вокруг оси Z на угол θ:
          \[
          R_z(\theta) = \begin{bmatrix}
          \cos\theta & -\sin\theta & 0 & 0 \\
          \sin\theta & \cos\theta & 0 & 0 \\
          0 & 0 & 1 & 0 \\
          0 & 0 & 0 & 1
          \end{bmatrix}
          \]

4. **Отражение (Reflection)**:
    - Отражение объекта относительно плоскости или оси.
    - **Пример матрицы отражения относительно плоскости XY**:
      \[
      F = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 0 & 0 \\
      0 & 0 & -1 & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}
      \]

5. **Сдвиг (Shearing)**:
    - Искажение объекта с сохранением параллельности сторон.
    - **Матрица сдвига по оси X относительно оси Y**:
      \[
      Sh_x = \begin{bmatrix}
      1 & sh_{xy} & 0 & 0 \\
      0 & 1 & 0 & 0 \\
      0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}
      \]

### 5.3. Структура матрицы преобразования однородных координат для 3D пространства

В однородных координатах для трехмерного пространства аффинные преобразования описываются 4x4 матрицами. Это позволяет объединять линейные преобразования и переносы в одной матрице.

**Общая форма матрицы аффинного преобразования**:
\[
M = \begin{bmatrix}
m_{11} & m_{12} & m_{13} & t_x \\
m_{21} & m_{22} & m_{23} & t_y \\
m_{31} & m_{32} & m_{33} & t_z \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

- **Левая верхняя 3x3 часть** отвечает за линейные преобразования (поворот, масштабирование, сдвиг и т.д.).
- **Последний столбец** содержит компоненты переноса (t_x, t_y, t_z).
- **Нижний ряд** всегда равен [0, 0, 0, 1], что обеспечивает сохранение однородности координат.

### 5.4. Пример комбинированного аффинного преобразования

Предположим, необходимо выполнить следующие преобразования:
1. Масштабирование по осям X, Y, Z с коэффициентами s_x, s_y, s_z.
2. Поворот вокруг оси Y на угол θ.
3. Перенос на вектор (t_x, t_y, t_z).

**Последовательность матриц преобразований**:
\[
M = T \cdot R_y(\theta) \cdot S
\]

**Где**:
- \( S \) — матрица масштабирования.
- \( R_y(\theta) \) — матрица поворота вокруг оси Y.
- \( T \) — матрица переноса.

**Код на C++ с использованием Qt**:
```cpp
#include <QMatrix4x4>
#include <QVector3D>

QMatrix4x4 createTransformationMatrix(float s_x, float s_y, float s_z, float theta, float t_x, float t_y, float t_z) {
    QMatrix4x4 scaleMatrix;
    scaleMatrix.setToIdentity();
    scaleMatrix.scale(s_x, s_y, s_z);

    QMatrix4x4 rotationMatrix;
    rotationMatrix.setToIdentity();
    rotationMatrix.rotate(theta, QVector3D(0, 1, 0)); // Поворот вокруг оси Y

    QMatrix4x4 translationMatrix;
    translationMatrix.setToIdentity();
    translationMatrix.translate(t_x, t_y, t_z);

    // Компоновка матриц: Сначала масштабирование, затем поворот, затем перенос
    QMatrix4x4 transformation = translationMatrix * rotationMatrix * scaleMatrix;

    return transformation;
}
```

