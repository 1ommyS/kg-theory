
## 36. Краткая характеристика языка GLSL (или HLSL).

### 36.1. Язык GLSL (OpenGL Shading Language)

#### Определение

**GLSL** (OpenGL Shading Language) — это высокоуровневый шейдерный язык, разработанный для написания вершинных, фрагментных и других типов шейдеров в OpenGL. Он интегрирован непосредственно в OpenGL и предоставляет разработчикам возможность программировать графический конвейер на GPU.

#### Основные характеристики GLSL

1. **Синтаксис, похожий на C**:
    - GLSL имеет синтаксис, похожий на язык программирования C, что облегчает его изучение для разработчиков с опытом в C/C++.

2. **Типизация**:
    - Поддерживает сильную статическую типизацию, включая базовые типы (int, float), векторы (vec2, vec3, vec4), матрицы (mat2, mat3, mat4) и структуры.

3. **Встроенные функции и операции**:
    - Включает множество встроенных математических функций (sin, cos, pow, dot, cross и т.д.) и операторов для выполнения сложных вычислений.

4. **Параллельное выполнение**:
    - Шейдеры исполняются параллельно на GPU, что позволяет эффективно обрабатывать большие объёмы данных.

5. **Параметры и униформы**:
    - Поддерживает униформы, атрибуты и варьируемые параметры для передачи данных между приложением и шейдерами.

6. **Различные стадии шейдерного конвейера**:
    - Вершинные шейдеры, фрагментные шейдеры, геометрические шейдеры, тесселяционные шейдеры и вычислительные шейдеры.

#### Пример простого фрагментного шейдера на GLSL

```glsl
#version 330 core
out vec4 FragColor;

uniform vec3 objectColor;
uniform vec3 lightColor;
uniform vec3 lightPos;
uniform vec3 viewPos;
in vec3 FragPos;
in vec3 Normal;

void main()
{
    // Фоновое освещение
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Рассеянное освещение
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Зеркальное освещение
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}
```

### 36.2. Язык HLSL (High-Level Shading Language)

#### Определение

**HLSL** (High-Level Shading Language) — это высокоуровневый шейдерный язык, разработанный Microsoft для использования в Direct3D. Он предназначен для написания вершинных, пиксельных (фрагментных) и других типов шейдеров, обеспечивая программистам гибкий и мощный инструмент для рендеринга графики на GPU.

#### Основные характеристики HLSL

1. **Синтаксис, похожий на C**:
    - HLSL имеет синтаксис, схожий с языком программирования C, что облегчает его освоение для разработчиков с опытом в C/C++.

2. **Типизация**:
    - Поддерживает сильную статическую типизацию, включая базовые типы (int, float), векторы (float2, float3, float4), матрицы (float2x2, float3x3, float4x4) и структуры.

3. **Встроенные функции и операции**:
    - Включает множество встроенных математических функций (sin, cos, pow, dot, cross и т.д.) и операторов для выполнения сложных вычислений.

4. **Параллельное выполнение**:
    - Шейдеры исполняются параллельно на GPU, что позволяет эффективно обрабатывать большие объёмы данных.

5. **Параметры и униформы**:
    - Поддерживает константные буферы, текстуры, семплеры и другие типы ресурсов для передачи данных между приложением и шейдерами.

6. **Различные стадии шейдерного конвейера**:
    - Вершинные шейдеры, пиксельные шейдеры, геометрические шейдеры, тесселяционные шейдеры и вычислительные шейдеры.

#### Пример простого пиксельного шейдера на HLSL

```hlsl
// Pixel Shader
struct PS_INPUT
{
    float4 pos : SV_POSITION;
    float3 normal : NORMAL;
    float3 fragPos : TEXCOORD0;
};

cbuffer Lighting : register(b0)
{
    float3 lightPos;
    float3 viewPos;
    float3 lightColor;
    float3 objectColor;
};

float4 main(PS_INPUT input) : SV_TARGET
{
    // Фоновое освещение
    float ambientStrength = 0.1f;
    float3 ambient = ambientStrength * lightColor;
    
    // Рассеянное освещение
    float3 norm = normalize(input.normal);
    float3 lightDir = normalize(lightPos - input.fragPos);
    float diff = max(dot(norm, lightDir), 0.0f);
    float3 diffuse = diff * lightColor;
    
    // Зеркальное освещение
    float specularStrength = 0.5f;
    float3 viewDir = normalize(viewPos - input.fragPos);
    float3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);
    float3 specular = specularStrength * spec * lightColor;
    
    float3 result = (ambient + diffuse + specular) * objectColor;
    return float4(result, 1.0f);
}
```

### 36.3. Сравнение GLSL и HLSL

| **Критерий**         | **GLSL**                               | **HLSL**                                |
|----------------------|----------------------------------------|-----------------------------------------|
| **Платформозависимость** | Кроссплатформенный, используется в OpenGL | Ограничен Windows и DirectX              |
| **Синтаксис**        | Похож на C, поддерживает GLSL специфичные функции | Похож на C, включает DirectX специфичные функции |
| **Типизация**        | Строгая типизация с поддержкой векторов и матриц | Строгая типизация с поддержкой векторов и матриц |
| **Интеграция**       | Интегрирован с OpenGL                  | Интегрирован с Direct3D                  |
| **Поддержка расширений** | Высокая, позволяет добавлять новые функции | Ограниченная, зависит от версии DirectX |
| **Совместимость с инструментами** | Широкая поддержка в различных 3D-приложениях | Используется преимущественно в приложениях на Windows |

### 36.4. Заключение

GLSL и HLSL являются мощными инструментами для создания шейдерных программ в соответствующих графических API. Выбор между ними зависит от платформы и конкретных требований проекта. Оба языка предоставляют разработчикам высокую степень контроля над графическим процессом, позволяя реализовывать сложные визуальные эффекты и оптимизировать рендеринг.

---
