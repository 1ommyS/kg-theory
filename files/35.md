
## 35. Понятие о шейдерной графике. Использование шейдеров в OpenGL (или Direct3D). Фрагментные и вершинные шейдеры.

### 35.1. Понятие о шейдерной графике

**Шейдерная графика** — это подход к программированию графических процессоров (GPU), позволяющий разработчикам создавать программы (шейдеры) для обработки графических данных. Шейдеры управляют тем, как вершины и фрагменты (пиксели) обрабатываются и визуализируются, обеспечивая высокую степень контроля над рендерингом и возможностью реализации сложных визуальных эффектов.

### 35.2. Типы шейдеров

1. **Вершинные шейдеры (Vertex Shaders)**:
    - Обрабатывают каждый вершину трёхмерной модели.
    - Выполняют трансформации вершин (поворот, масштабирование, перенос), вычисляют нормали и другие атрибуты.

2. **Фрагментные шейдеры (Fragment Shaders)**:
    - Обрабатывают каждый фрагмент (пиксель) изображения.
    - Вычисляют цвет пикселя, учитывая освещение, текстуры и другие эффекты.

3. **Геометрические шейдеры (Geometry Shaders)**:
    - Обрабатывают геометрические примитивы (точки, линии, треугольники).
    - Могут генерировать новые примитивы или изменять существующие.

4. **Тесселяционные шейдеры (Tessellation Shaders)**:
    - Отвечают за разбиение примитивов на более мелкие элементы для увеличения детализации.

5. **Шейдеры вычислений (Compute Shaders)**:
    - Позволяют выполнять общие вычисления на GPU, не связанные напрямую с рендерингом.

### 35.3. Использование шейдеров в OpenGL

В OpenGL шейдеры пишутся на языке **GLSL (OpenGL Shading Language)** и загружаются в графический конвейер для выполнения на GPU. Основные шаги использования шейдеров в OpenGL:

1. **Написание шейдеров**:
    - Создание вершинного и фрагментного шейдеров на языке GLSL.

2. **Компиляция шейдеров**:
    - Компиляция исходного кода шейдеров в бинарный формат, понятный GPU.

3. **Связывание шейдеров**:
    - Объединение компилированных шейдеров в шейдерную программу (shader program).

4. **Использование шейдерной программы**:
    - Активизация шейдерной программы для рендеринга объектов.

5. **Передача данных**:
    - Передача атрибутов вершин, униформов и других данных в шейдеры.

#### Пример простого вершинного и фрагментного шейдера в OpenGL

**Вершинный шейдер (vertex_shader.glsl):**

```glsl
#version 330 core
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(position, 1.0));
    Normal = mat3(transpose(inverse(model))) * normal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

**Фрагментный шейдер (fragment_shader.glsl):**

```glsl
#version 330 core
in vec3 FragPos;
in vec3 Normal;

out vec4 color;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 objectColor;
uniform vec3 lightColor;

void main()
{
    // Фоновое освещение
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Рассеянное освещение
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Зеркальное освещение
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    color = vec4(result, 1.0);
}
```

### 35.4. Использование шейдеров в Direct3D

В **Direct3D** шейдеры пишутся на языке **HLSL (High-Level Shading Language)** и проходят схожие этапы компиляции и связывания. Основные шаги использования шейдеров в Direct3D:

1. **Написание шейдеров**:
    - Создание вершинных и пиксельных шейдеров на языке HLSL.

2. **Компиляция шейдеров**:
    - Компиляция исходного кода шейдеров в бинарный формат.

3. **Создание шейдерных объектов**:
    - Создание объектов шейдеров (например, ID3D11VertexShader, ID3D11PixelShader).

4. **Установка шейдеров**:
    - Привязка шейдерных объектов к графическому конвейеру.

5. **Передача данных**:
    - Передача атрибутов вершин, униформов и других данных в шейдеры.

### 35.5. Достоинства шейдерной графики

1. **Гибкость**:
    - Позволяет создавать разнообразные визуальные эффекты, контролируя процесс рендеринга на уровне GPU.

2. **Производительность**:
    - Высокая параллельная производительность GPU позволяет обрабатывать шейдерные вычисления эффективно.

3. **Кастомизация**:
    - Разработчики могут создавать уникальные шейдерные программы для достижения специфических визуальных результатов.

4. **Совместимость**:
    - Шейдерная графика интегрирована в современные графические API, такие как OpenGL и Direct3D, обеспечивая широкую поддержку.

5. **Реалистичность**:
    - Позволяет реализовывать сложные модели освещения и текстурирования для достижения реалистичных изображений.

### 35.6. Недостатки шейдерной графики

1. **Сложность**:
    - Требует знания шейдерных языков и понимания графического конвейера для эффективного использования.

2. **Зависимость от аппаратного обеспечения**:
    - Производительность и возможности зависят от мощности и поддержки GPU.

3. **Ошибки и отладка**:
    - Шейдерные программы могут быть сложными для отладки, особенно при наличии ошибок в логике или синтаксисе.

4. **Кроссплатформенность**:
    - Хотя OpenGL обеспечивает кроссплатформенную совместимость, Direct3D ограничен Windows и Xbox.

### 35.7. Заключение

Шейдерная графика предоставляет мощные инструменты для создания реалистичных и сложных визуальных эффектов, обеспечивая высокий уровень контроля над процессом рендеринга. Несмотря на сложности в реализации и отладке, её преимущества делают её незаменимой в современных приложениях компьютерной графики и рендеринга.

---
